# 位运算

判断一个数的二进制有几个1
```go
for n > 0 {
    if n & 1 == 1 {
        ...
    }
    count++
}
```

负数的最高位为1,上面算法处理负数时会进入死循环

## 复杂度n(logN)的算法
当`n-1`的时候,n的最低位1会变成0, 后面的位变成1.这样只要循环`m`次就能计算出.

### 复杂度分析

* 时间复杂度：$O(logn)$。循环次数等于 `n` 的二进制位中 `1` 的个数，最坏情况下 `n` 的二进制位全部为 `1`。我们需要循环 $logn$ 次。

* 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。
