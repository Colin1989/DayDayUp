# 位运算

### 分治法（divide-and-conquer）

将问题拆分成n个结构与原问题相识的子问题.递归的解决这些子问题,然后合并其结果.就能得到原问题的结果

`分治法`是指将问题划分成一些独立地子问题，递归地求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，`动态规划`适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题

### 倒数
数学上，一个数$x$的倒数（英语：reciprocal），是指一个与$x$相乘的积为1的数，记为$\cfrac{x}{1}$或$x^{-1}$。在抽象代数中，倒数所对应的抽象化概念是乘法群的某个元素的`乘法逆`，也就是相对于群中“乘法”运算的逆元素。

## 快速幂 + 递归
「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ 
 ，我们可以按照：
 
$$x \rightarrow x^{2} \rightarrow x^{4} \rightarrow x^{8} \rightarrow x^{16} \rightarrow x^{32} \rightarrow x^{64}$$

从$x$开始,把上次的结果平方,计算6次就可以等到$x^{64}$的结果.

### 总结
* 当我们要计算$x^{n}$,先递归计算出$y=x^{n/2}$.
* 当`n`为偶数时$x^{n}=y^{2}$.如果`n`为奇数,$x^{n}=y^{2}*x$
* 幂为`0`时,任意数的`0`次方为1
* 幂为负数且`n`为0时,需要特殊处理为`0`

### 复杂度
* 时间复杂度：$O(logn)$，即为递归的层数。
* 空间复杂度：$O(logn)$，即为递归的层数。这是由于递归的函数调用会使用栈空间。
## 快速幂 + 迭代

由于迭代需要额外的栈空间,使用迭代可以节省内存.

在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 $x$。但我们不妨找一找规律，看看哪些地方额外乘了 $x$，并且它们对答案产生了什么影响。

我们还是以 $x^{77}$ 作为例子：

 
$$x \rightarrow x^{2} \rightarrow x^{4} \rightarrow^{+}x^{9} \rightarrow^{+}x^{19} \rightarrow^{+} x^{38} \rightarrow^{+}x^{77}$$

并且把需要额外乘 $x$ 的步骤打上了 $+$ 标记。可以发现：
* $x^{38} \rightarrow^{+} x^{77}$中额外乘的$x$在$x^{77}$中贡献了$x$
* $x^{9} \rightarrow^{+}x^{19}$中额外乘的$x$在之后被平方了$2$次,$x^{77}$中贡献了${x^{2}}^{2} = x^{4}$
* $x^{4} \rightarrow^{+}x^{9}$中额外乘的$x$在之后被平方了$3$次,$x^{77}$中贡献了${x^{2}}^{3} = x^{8}$
* 最初的$x$在之后被平方了$6$次,因此在$x^{77}$中贡献了${x^{2}}^{6} = x^{64}$
  
我们把这些贡献相乘，$x \times x^{4} \times x^{8} \times x^{64}$ 恰好等于 $x^{77}$。而这些贡献的指数部分又是什么呢？它们都是 $2$ 的幂次，这是因为每个额外乘的 $x$ 在之后都会被平方若干次。而这些指数 $1,4,8 和 64$，**恰好就对应了 $77$ 的二进制表示 $(1001101)_2$​ 中的每个 $1$！**

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 $n$ 的二进制拆分为

$$n = 2^{i0} + 2^{i1} + ... + 2^{ik}$$

那么

$$x^n = {x^2}^{i0} \times {x^2}^{i1} \times ... \times {x^2}^{ik}$$

这样以来，我们从 $x$ 开始不断地进行平方，得到 $x^{2}, x^{4}, x^{8}, x^{16},⋯$ 如果 $n$ 的第 $k$ 个（从右往左，从 $0$ 开始计数）二进制位为 $1$，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。

### 复杂度
* 时间复杂度: $O(logn)$
* 空间复杂度: $O(1)$